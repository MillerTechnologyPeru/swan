//===--- RawAstTranslator.java -------------------------------------------===//
//
// This source file is part of the SWAN open source project
//
// Copyright (c) 2019 Maple @ University of Alberta
// All rights reserved. This program and the accompanying materials (unless
// otherwise specified by a license inside of the accompanying material)
// are made available under the terms of the Eclipse Public License v2.0
// which accompanies this distribution, and is available at
// http://www.eclipse.org/legal/epl-v20.html
//
//===---------------------------------------------------------------------===//

package ca.maple.swan.swift.translator;

import ca.maple.swan.swift.ipa.summaries.BuiltInFunctionSummaries;
import ca.maple.swan.swift.translator.values.*;
import ca.maple.swan.swift.tree.EntityPrinter;
import ca.maple.swan.swift.tree.FunctionEntity;
import ca.maple.swan.swift.tree.ScriptEntity;
import ca.maple.swan.swift.tree.SwiftFunctionType;
import com.ibm.wala.cast.ir.translator.AbstractCodeEntity;
import com.ibm.wala.cast.tree.*;
import com.ibm.wala.cast.tree.impl.CAstImpl;
import com.ibm.wala.cast.tree.impl.CAstOperator;
import com.ibm.wala.util.collections.Pair;
import com.ibm.wala.util.debug.Assertions;

import java.io.File;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.HashMap;

/*****************************  AST FORMAT ************************************

    This is the main translator for SIL to WALA CAst. It expects a particular
    format (generated by the C++ side) built using CAst (mostly for convenience).
    The given CAst is basically just all raw information needed to translate
    the instructions.

    -----------------

    Note: "node" here means PRIMITIVE.

    Every function is represented by one parent node. The C++ translator
    returns a single CAstNode with every one of these "parent" nodes as
    children.

    The first child of the function contains the basic block nodes.

    The second node under a function node has the meta information.

    Basic blocks' node's children represent the instructions.

    ### Function meta information format:

    NAME (CONSTANT)
    RETURN_TYPE (CONSTANT)
    JOBJECT <-- FUNCTION_POSITION
    PRIMITIVE <--- ARGUMENTS
        PRIMITIVE <--- ARGUMENT
            NAME
            TYPE
            JOBJECT <-- ARGUMENT_POSITION
        ...

    ### Basic block format:

    PRIMITIVE <-- ARGUMENTS
        PRIMITIVE <-- ARG
            NAME
            TYPE
        ...
    PRIMITIVE <-- INSTRUCTION_INFORMATION
        NAME
        JOBJECT <-- INSTRUCTION_POSITION
        ... <-- ANYTHING_NEEDED_TO_TRANSLATE_INSTRUCTION
    ...

    ### Instruction format:

    PRIMITIVE <--- OPERANDS
        PRIMITIVE <--- OPERAND
            NAME
            TYPE
        ...
    PRIMITIVE <--- RESULTS
        PRIMITIVE <--- RESULT
            NAME
            TYPE
        ...
    (ANYTHING ELSE)

    -----------------

    This translator tries to limit the amount of CAst it generates
    by caching (if possible) into the SILValueTable instead of immediately
    creating CAst for each instruction.

    In order to do away with low level problems, such as pointers which WALA
    doesn't support, we keep track of the values ourselves with the
    following classes.

    SILConstant
        Useful for literals.

    SILEnum
        Used for keeping track of enums. An enum in SIL can have attached
        data, so we just store this under the arbitrary field name "value".

    SILField
        Instead of holding a copy of a field, we can generate an OBJECT_REF
        each time we use the value.

    SILFunctionRef
        Simply holds the name of a function, used for explicitness as
        opposed to SILConstant

    SILFunctionRef.SILSummarizedFunctionRef
        Used to explicitly mark functions as summarizable.

    SILPointer
        We can keep track of a pointer's underlying value using this class.
        This class does not have to have an underlying value, so we need
        to check if it has an underlying value ( hasValue() ). This is so
        that instructions that create pointers such as alloc_stack can be
        handled explicitly. Typically any type starting with $*.

        We want as much as possibly 1:1 representation type wise. So if
        an instruction expects a pointer as an operand, we have to make sure
        it exists as a SILPointer in our table.

    SILStruct
        Used to represent structs, but can really represent any object with
        named fields. Can generate SILFields.

    SILTuple
        Same as SILStruct but field names are (obviously) numbers.
        Holds 2 values.

    SILValue
        Base class that can also hold its own as a generic value.

    -----------------

    NOTES:

    We index assuming we have the correct number of results/operands.
    Exception handling will make it obvious if we are indexing wrong.

    We need to be careful to handle built in pointers such as
    $*Builtin.UnsafeValueBuffer which are most likely introduced via built in
    functions.

    $Builtin.RawPointer are regular pointers to us.

    Treating references like regular values may be an extremely naive and
    problematic approach. e.g. project_box might be inaccurate. Depends on
    how boxes are introduced, esp by built in functions.

    Function args are equal to bb0 args.

    Assignment folding is delicate as some instructions MUST be directly
    represented in the CAst, such as `store`. In general, we need to
    carefully consider what stays in the background, and what shows
    in the CAst. We may have to make some copies explicit assignments
    later. However, things like casts should be okay to fold.

    We do support deallocation instructions for completeness, but this
    theoretically has no effect as SIL opaque values are unique.

    Type information may not be perfect due to careless assignment folding.
    This is fine for now as long as allocation sites have the right type
    which would translate to CAst NEW instruction.

    We do not keep track of fields concretely. This is difficult to do
    statically as naturally fields are used in a dynamic matter.

    For now, any instruction that we have never seen before, we
    don't translate.

    Metatype/Existential stuff is mostly marked at MED confidence since
    maybe we are naive to think we shouldn't care about that. For now
    we just copy as much as possible.

    TODO:

        - Function refs to inlined functions that are never called
          are problematic because WALA will try to find a CAstEntity
          (call site) for that function expression.

        SOLUTION: KEEP TRACK OF DANGLING FUNCTION_REFS.

        - Dynamic method dispatches to methods expecting a pointer as
          a param are not inlineable. The best we can do here is pass
          by value.

 *****************************************************************************/

/*
 * Translates a raw, custom formatted AST into a complete AST. The result
 * is the root entity of the file being analyzed.
 */

@SuppressWarnings("unused")
public class RawAstTranslator extends SILInstructionVisitor<CAstNode, SILInstructionContext> {

    public static final CAstImpl Ast = new CAstImpl();

    public CAstEntity translate(File file, CAstNode n) {

        // 1. Create CAstEntity for each function.
        HashMap<String, AbstractCodeEntity> allEntities = new HashMap<>();
        HashMap<CAstNode, AbstractCodeEntity>  mappedEntities = new HashMap<>();

        AbstractCodeEntity scriptEntity = null;

        for (CAstNode function : n.getChildren()) {
            AbstractCodeEntity newEntity;
            if ((getStringValue(function, 0)).equals("main")) {
                newEntity = makeScriptEntity("main", file);
                scriptEntity = newEntity;
            } else {
                newEntity = makeFunctionEntity(function);
            }
            allEntities.put(newEntity.getName(), newEntity);
            mappedEntities.put(function, newEntity);
        }

        // 2. Analyze each entity.
        for (CAstNode function: mappedEntities.keySet()) {
            SILInstructionContext C = new SILInstructionContext(mappedEntities.get(function), allEntities, function);
            if (Inliner.shouldInlineFunction(C.parent.getName(), C)) { continue; }
            // TODO: Script entity also has params, but are they ever used?
            if (C.parent instanceof FunctionEntity) {
                int i = 0;
                for (String argName : C.parent.getArgumentNames()) {
                    String argType = ((SwiftFunctionType)C.parent.getType()).realTypes.get(i);
                    C.valueTable.addArg(new SILValue(argName, argType, C));
                    ++i;
                }
            }
            int blockNo =  0;
            for (CAstNode block: function.getChild(4).getChildren()) {
                if (Inliner.shouldInlineBlock(blockNo, C)) { continue; }
                C.clearInstructions();
                for (CAstNode instruction: block.getChildren().subList(1, block.getChildren().size())) {
                    try {
                        CAstNode Node = this.visit(instruction, C);
                        if ((Node != null) && (Node.getKind() != CAstNode.EMPTY)) {
                            C.instructions.add(Node);
                        }
                    } catch (Throwable e) {
                        System.err.println("ERROR: " + instruction.getChild(0).getValue() + " failed to translate");
                        System.err.println("\t Function: " + C.parent.getName() + " | " + "Block: #" + blockNo);
                        System.err.println("\t" + instruction.toString().replaceAll("\n", "\n\t"));
                        e.printStackTrace();
                    }
                }
                C.instructions.addAll(0, C.valueTable.getDecls());
                C.instructions.add(0, Ast.makeNode(CAstNode.LABEL_STMT,
                        Ast.makeConstant(blockNo)));
                C.blocks.add(C.instructions);
                ++blockNo;
            }
            int i = 1; // Assuming BB0 is never branched to.
            for (ArrayList<CAstNode> block : C.blocks.subList(1, C.blocks.size())) {
                CAstNode BlockStmt = Ast.makeNode(CAstNode.BLOCK_STMT, block);
                if (C.danglingGOTOs.containsKey(i)) {
                    for (CAstNode dangling : C.danglingGOTOs.get(i)) {
                        C.parent.setGotoTarget(dangling, BlockStmt);
                    }
                }
                C.blocks.get(0).add(BlockStmt);
                ++i;
            }
            mappedEntities.get(function).setAst(Ast.makeNode(CAstNode.BLOCK_STMT, C.blocks.get(0)));
            // EntityPrinter.print(mappedEntities.get(function));
        }

        // For debugging : generate dot output. Should turn off for large code.
        // ASTtoDot.print(allEntities);

        return scriptEntity;
    }

    private static ScriptEntity makeScriptEntity(File file) {
        return new ScriptEntity(file.getName(), file);
    }

    private static ScriptEntity makeScriptEntity(String name, File file) {
        return new ScriptEntity(name, file);
    }

    private static FunctionEntity makeFunctionEntity(CAstNode n) {
        String name = (String)n.getChild(0).getValue();
        String returnType = (String)n.getChild(1).getValue();
        CAstSourcePositionMap.Position functionPosition = (CAstSourcePositionMap.Position)n.getChild(2).getValue();
        ArrayList<String> argumentNames = new ArrayList<>();
        ArrayList<String> argumentTypes = new ArrayList<>();
        ArrayList<CAstSourcePositionMap.Position> argumentPositions = new ArrayList<>();
        for (CAstNode arg : n.getChild(3).getChildren()) {
            String argName = (String)arg.getChild(0).getValue();
            String argType = (String)arg.getChild(1).getValue();
            argumentNames.add(argName);
            argumentTypes.add(argType);
            argumentPositions.add((CAstSourcePositionMap.Position)arg.getChild(2).getValue());
        }
        argumentNames.add(0, "self"); // TEMPORARY
        argumentTypes.add(0, "self");
        argumentPositions.add(0, null);
        return new FunctionEntity(name, returnType, argumentTypes, argumentNames, functionPosition, argumentPositions, n);
    }

    public static AbstractCodeEntity findEntity(String name, HashMap<String, AbstractCodeEntity> entities) {
        if (entities.containsKey(name)) {
            return entities.get(name);
        } else {
            System.err.println("ERROR: Entity with name " + name + " not found");
            new Exception().printStackTrace();
            return null;
        }
    }

    private static void tryGOTO(CAstNode n, String label, SILInstructionContext C) {
        int bb = Integer.parseInt(label);
        if (bb <= C.blocks.size()) {
            C.parent.setGotoTarget(n, C.blocks.get(bb).get(0));
        } else {
            if (!C.danglingGOTOs.containsKey(bb)) {
                C.danglingGOTOs.put(bb, new ArrayList<>());
            }
            C.danglingGOTOs.get(bb).add(n);
        }
    }

    public static class RawValue {
        public final String Name;
        public final String Type;
        public RawValue(String name, String type) {
            this.Name = name;
            this.Type = type;
        }
        public RawValue(String name) {
            this(name, null);
        }
    }

    private static Pair<ArrayList<RawValue>, ArrayList<RawValue>> getOperandsAndResults(CAstNode N) {
        // TODO: cache the results so that subsequent calls such as
        //       getResult()/getOperand() don't call this whole process each time?
        Assertions.productionAssertion(N.getChildren().size() >= 2);
        ArrayList<RawValue> operands = new ArrayList<>();
        ArrayList<RawValue> results = new ArrayList<>();
        for (CAstNode operand : N.getChild(0).getChildren()) {
            operands.add(new RawValue(
                    (String)operand.getChild(0).getValue(),
                    (String)operand.getChild(1).getValue()));
        }
        for (CAstNode result : N.getChild(1).getChildren()) {
            results.add(new RawValue(
                    (String)result.getChild(0).getValue(),
                    (String)result.getChild(1).getValue()));
        }
        return Pair.make(operands, results);
    }

    private static RawValue getSingleResult(CAstNode N) {
        return getResult(N, 0);
    }

    public static RawValue getResult(CAstNode N, int index) {
        return getOperandsAndResults(N).snd.get(index);
    }

    private static RawValue getSingleOperand(CAstNode N) {
        return getOperand(N, 0);
    }

    private static RawValue getOperand(CAstNode N, int index) {
        return getOperandsAndResults(N).fst.get(index);
    }

    public static String getStringValue(CAstNode N, int index) {
        Assertions.productionAssertion(N.getChildren().size() > index);
        return (String)N.getChild(index).getValue();
    }

    public static int getIntValue(CAstNode N, int index) {
        Assertions.productionAssertion(N.getChildren().size() > index);
        return (int)N.getChild(index).getValue();
    }

    @Override
    protected CAstSourcePositionMap.Position getInstructionPosition(CAstNode N) {
        return (CAstSourcePositionMap.Position)N.getChild(1).getValue();
    }


    /********************** INSTRUCTION TRANSLATION **********************
     * Every instruction has some extra information commented before it.
     *
     * FREQUENCY: How often this instruction occurs in test cases. This is
     *            just set relative to the frequency of other instructions.
     *            VERY COMMON > COMMON > UNCOMMON > RARE > UNSEEN
     * STATUS: Whether this instruction is translated.
     * CONFIDENCE: Confidence level of translation. e.g. LOW would probably
     *             mean its an initial translation based off SIL.rst but
     *             could be wrong in practice.
     */

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitAllocStack(CAstNode N, SILInstructionContext C) {
        // Since we are creating a pointer, we use a SILPointer to be explicit.
        RawValue result = getSingleResult(N);
        SILPointer ResultValue = new SILPointer(result.Name, result.Type, C);
        C.valueTable.addValue(ResultValue);
        return Ast.makeNode(CAstNode.ASSIGN,
                ResultValue.getVarNode(),
                Ast.makeNode(CAstNode.NEW, Ast.makeConstant(result.Type)));
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitAllocRef(CAstNode N, SILInstructionContext C) {
        // We are allocating a reference to an object, so no pointer here.
        // We ignore the operand which specifies irrelevant memory information.
        RawValue result = getSingleResult(N);
        SILValue ResultValue = new SILPointer(result.Name, result.Type, C);
        C.valueTable.addValue(ResultValue);
        return Ast.makeNode(CAstNode.ASSIGN,
                ResultValue.getVarNode(),
                Ast.makeNode(CAstNode.NEW, Ast.makeConstant(result.Type)));
    }

    @Override
    // FREQUENCY: UNCOMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitAllocRefDynamic(CAstNode N, SILInstructionContext C) {
        // We are allocating a reference to an object, so no pointer here.
        // First operand specifies metatype value (hence dynamic) but we can ignore
        // it since we know the type of the result anyway.
        // We ignore the second operand which specifies irrelevant memory information.
        RawValue result = getSingleResult(N);
        SILValue ResultValue = new SILValue(result.Name, result.Type, C);
        C.valueTable.addValue(ResultValue);
        return Ast.makeNode(CAstNode.ASSIGN,
                ResultValue.getVarNode(),
                Ast.makeNode(CAstNode.NEW, Ast.makeConstant(result.Type)));
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitAllocBox(CAstNode N, SILInstructionContext C) {
        // We treat $@box as regular pointers, so its the same as the
        // other pointer allocations.
        RawValue result = getSingleResult(N);
        SILPointer ResultValue = new SILPointer(result.Name, result.Type, C);
        C.valueTable.addValue(ResultValue);
        return Ast.makeNode(CAstNode.ASSIGN,
                ResultValue.getVarNode(),
                Ast.makeNode(CAstNode.NEW, Ast.makeConstant(result.Type)));
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitAllocValueBuffer(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitAllocGlobal(CAstNode N, SILInstructionContext C) {
        // Allocate a global which is identified by a name. Should technically
        // be a pointer, but doesn't matter for now since an empty pointer
        // points to itself.
        String GlobalName = getStringValue(N, 0);
        String GlobalType = getStringValue(N, 1);
        SILValue ResultValue = new SILValue(GlobalName, GlobalType, C);
        C.valueTable.addValue(ResultValue);
        return Ast.makeNode(CAstNode.ASSIGN,
                ResultValue.getVarNode(),
                Ast.makeNode(CAstNode.NEW, Ast.makeConstant(GlobalType)));
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitDeallocStack(CAstNode N, SILInstructionContext C) {
        // Deallocates memory previously allocated by alloc_stack.
        // We expect to have already destroyed the underlying memory value so we
        // just remove the pointer itself from the table.
        RawValue operand = getSingleOperand(N);
        C.valueTable.removeValue(operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitDeallocBox(CAstNode N, SILInstructionContext C) {
        // Deallocates a $@box. Does not destroy the contents of the box,
        // so we only need to remove the value itself.
        RawValue operand = getSingleOperand(N);
        C.valueTable.removeValue(operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitProjectBox(CAstNode N, SILInstructionContext C) {
        // A box's address and its underlying val's address are equal to us.
        RawValue result = getSingleResult(N);
        RawValue operand = getSingleOperand(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitDeallocRef(CAstNode N, SILInstructionContext C) {
        // Remove the value from the table since it is just a reference.
        RawValue operand = getSingleOperand(N);
        C.valueTable.removeValue(operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitDeallocPartialRef(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitDeallocValueBuffer(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitProjectValueBuffer(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitDebugValue(CAstNode N, SILInstructionContext C) {
        // NOP
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitDebugValueAddr(CAstNode N, SILInstructionContext C) {
        // NOP
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitLoad(CAstNode N, SILInstructionContext C) {
        // Copies the underlying value of the operand pointer to the result value.
        // This is an explicit copy so we do not copy anything on the value table side.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        SILValue OperandValue = C.valueTable.getValue(operand.Name);
        Assertions.productionAssertion(OperandValue instanceof SILPointer);
        SILValue UnderlyingValue = ((SILPointer)OperandValue).dereference();
        SILValue ResultValue = new SILValue(result.Name, result.Type, C);
        C.valueTable.addValue(ResultValue);
        return UnderlyingValue.assignTo(ResultValue);
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitStore(CAstNode N, SILInstructionContext C) {
        // Store the source value to the memory of the dest pointer.
        // This is an explicit operation, but we still need to replace the
        // underlying value of the dest pointer.
        String SourceName = getStringValue(N, 0);
        String DestName = getStringValue(N, 1);
        SILValue SourceValue = C.valueTable.getValue(SourceName);
        SILValue DestValue = C.valueTable.getValue(DestName);
        Assertions.productionAssertion(DestValue instanceof SILPointer);
        CAstNode AssignNode = SourceValue.assignTo(((SILPointer) DestValue).dereference());
        ((SILPointer) DestValue).replaceUnderlyingVar(SourceValue);
        return AssignNode;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: MED
    protected CAstNode visitStoreBorrow(CAstNode N, SILInstructionContext C) {
        // No documentation on this instruction, so we treat it the same as store.
        return visitStore(N, C);
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitLoadBorrow(CAstNode N, SILInstructionContext C) {
        // We can treat this the same as load because the borrowed scope is
        // going to be within the function scope, which is the same as the
        // value table scope.
        return visitLoad(N, C);
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: MED
    protected CAstNode visitBeginBorrow(CAstNode N, SILInstructionContext C) {
        // No SIL.rst documentation. For now, just treat it the same as load.
        return visitLoad(N, C);
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitEndBorrow(CAstNode N, SILInstructionContext C) {
        // While the value that's begin borrowed from is given, we don't
        // care about it since we just want to make sure we don't use
        // the borrowed value itself again, so we just remove it.
        RawValue operand = getSingleOperand(N);
        C.valueTable.removeValue(operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitAssign(CAstNode N, SILInstructionContext C) {
        // Regular explicit assign to a pointer operand. We generate CAst and
        // replace the SILPointer value, too.
        String SourceName = getStringValue(N, 0);
        String DestName = getStringValue(N, 1);
        SILValue SourceValue = C.valueTable.getValue(SourceName);
        SILValue DestValue = C.valueTable.getValue(DestName);
        Assertions.productionAssertion(DestValue instanceof SILPointer);
        SILValue UnderlyingValue = ((SILPointer) DestValue).dereference();
        ((SILPointer)DestValue).replaceUnderlyingVar(SourceValue);
        return SourceValue.assignTo(UnderlyingValue);

    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: LOW
    protected CAstNode visitAssignByWrapper(CAstNode N, SILInstructionContext C) {
        // Assigns to the result through a conditional delegate. Two function refs
        // are given and called based on if the value needs to be initialized or
        // re-assigned. This is just an if-else call. The condition here could be
        // done by a custom operation, but for now an arbitrary condition is set.
        // TODO: Do regular apply handling here (checks/inlining/etc).
        RawValue source = getOperand(N, 0);
        RawValue dest = getOperand(N, 1);
        RawValue initFunc = getOperand(N, 2);
        RawValue setFunc = getOperand(N, 3);
        CAstNode CondNode = Ast.makeConstant("init/set");
        SILValue InitFuncRef = C.valueTable.getValue(initFunc.Name);
        Assertions.productionAssertion(InitFuncRef instanceof SILFunctionRef);
        SILValue SetFuncRef = C.valueTable.getValue(setFunc.Name);
        Assertions.productionAssertion(SetFuncRef instanceof SILFunctionRef);
        CAstNode InitCallNode = Ast.makeNode(CAstNode.CALL, InitFuncRef.getVarNode(),
                Ast.makeConstant("do"), C.valueTable.getValue(source.Name).getVarNode());
        CAstNode SetCallNode = Ast.makeNode(CAstNode.CALL, SetFuncRef.getVarNode(),
                Ast.makeConstant("do"), C.valueTable.getValue(source.Name).getVarNode());
        CAstNode DestNode = C.valueTable.getValue(dest.Name).getVarNode();
        CAstNode InitAssign = Ast.makeNode(CAstNode.ASSIGN, DestNode, InitCallNode);
        CAstNode SetAssign = Ast.makeNode(CAstNode.ASSIGN, DestNode, SetCallNode);
        return Ast.makeNode(CAstNode.IF_STMT, CondNode, InitAssign, SetAssign);
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitMarkUninitialized(CAstNode N, SILInstructionContext C) {
        // This instruction just marks memory location as unintialized, but the type
        // doesn't change so we can just do a value table copy.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitMarkFunctionEscape(CAstNode N, SILInstructionContext C) {
        // This instruction annotates memory, so we can just copy the value.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitMarkUninitializedBehavior(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitCopyAddr(CAstNode N, SILInstructionContext C) {
        // Copies the underlying value of the source into the destination.
        // This instruction is handled explicitly for now, but might be change
        // to a simple copy later.
        String SourceName = getStringValue(N, 0);
        String DestName = getStringValue(N, 1);
        SILValue SourceValue = C.valueTable.getValue(SourceName);
        SILValue DestValue = C.valueTable.getValue(DestName);
        Assertions.productionAssertion(SourceValue instanceof SILPointer);
        Assertions.productionAssertion(DestValue instanceof SILPointer);
        CAstNode AssignNode = SourceValue.assignTo(DestValue);
        ((SILPointer)DestValue).replaceUnderlyingVar(SourceValue);
        return AssignNode;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitDestroyAddr(CAstNode N, SILInstructionContext C) {
        // Destroys the underlying value at the given pointer.
        RawValue operand = getSingleOperand(N);
        SILValue AddrToDestroy = C.valueTable.getValue(operand.Name);
        Assertions.productionAssertion(AddrToDestroy instanceof SILPointer);
        C.valueTable.removeValue(((SILPointer)AddrToDestroy).dereference().getName());
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitIndexAddr(CAstNode N, SILInstructionContext C) {
        // A common use case of this instruction is indexing a string (which is
        // of course an array of chars in SIL) to get a character. Since we
        // represent a string as a literal, we would have to be able to
        // represent strings as an array in order to get a character with an
        // index. A possible workaround is a custom translation for a specific
        // AST structure we can generate for this case. e.g. OBJECT_REF on
        // a CONSTANT. For now, we treat it as an assignment of the whole
        // string to the result as this is generally sound for taint analysis.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitTailAddr(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitIndexRawPointer(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitBindMemory(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitBeginAccess(CAstNode N, SILInstructionContext C) {
        // Basically just copies the pointer given.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        SILValue OperandValue = C.valueTable.getValue(operand.Name);
        Assertions.productionAssertion(OperandValue instanceof SILPointer);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitEndAccess(CAstNode N, SILInstructionContext C) {
        // Ends an access to a memory location, and the operand is a copied
        // pointer so we can remove it safely from the value table.
        RawValue operand = getSingleOperand(N);
        C.valueTable.removeValue(operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitBeginUnpairedAccess(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitEndUnpairedAccess(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitStrongRetain(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitStrongRelease(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitSetDeallocating(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitStrongRetainUnowned(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitUnownedRetain(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitUnownedRelease(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitLoadWeak(CAstNode N, SILInstructionContext C) {
        // NOP
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: MED
    protected CAstNode visitStoreWeak(CAstNode N, SILInstructionContext C) {
        // It seems this is a regular store but with reference counting naunces.
        visitStore(N, C);
        return null;
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitLoadUnowned(CAstNode N, SILInstructionContext C) {
        // This instruction has no SIL.rst documentation. We see in practice
        // it takes a pointer as an operand, and assigns the underlying value
        // to the result. The difference here between a regular load is that
        // the result has a scope is most likely going to be destroyed with
        // destroy_value.
        return visitLoad(N, C);
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: UNHANDLED
    // CONFIDENCE: 
    protected CAstNode visitStoreUnowned(CAstNode N, SILInstructionContext C) {
        // This instruction has no SIL.rst documentation. We see in practice
        // the instructions stores a value to a pointer, with no side-effects.
        // This is a regular store as far as we know or care.
        return visitStore(N, C);
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitFixLifetime(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: MED
    protected CAstNode visitEndLifetime(CAstNode N, SILInstructionContext C) {
        // No SIL.rst documentation. Assume we can just remove the value.
        RawValue operand = getSingleOperand(N);
        C.valueTable.removeValue(operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitMarkDependence(CAstNode N, SILInstructionContext C) {
        // Indicates first operand depends on the second operand. We don't care about
        // this, but we do care that the result is equal to the first operand.
        C.valueTable.copyValue(getSingleResult(N).Name, getOperand(N, 0).Name);
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitIsUnique(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitIsEscapingClosure(CAstNode N, SILInstructionContext C) {
        // Treated the same as is_unique.
        RawValue result = getSingleResult(N);
        SILConstant IsUniqueVal = new SILConstant(result.Name, result.Type, C, "bool");
        C.valueTable.addValue(IsUniqueVal);
        return null;
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitCopyBlock(CAstNode N, SILInstructionContext C) {
        // Copies an objc block. We can treat this as a regular explicit copy for now.
        RawValue result = getSingleResult(N);
        RawValue operand = getSingleOperand(N);
        SILValue ResultValue = new SILValue(result.Name, result.Type, C);
        return C.valueTable.getValue(operand.Name).assignTo(ResultValue);
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitCopyBlockWithoutEscaping(CAstNode N, SILInstructionContext C) {
        // Same as copy_block for our purposes.
        return visitCopyBlock(N, C);
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitFunctionRef(CAstNode N, SILInstructionContext C) {
        // Creates a reference to a SIL function. Cases:
        // 1. Not built or summarized (regular function) - has representing entity
        // 2. Summarized (replaced when used in an apply) - representing entity
        // 3. Builtin function - replace with a constant value (this should be
        //    temporary until a summary is created for it) - TEMPORARY
        RawValue result = getSingleResult(N);
        String FuncName = getStringValue(N, 2);
        if (!BuiltInFunctionSummaries.isBuiltIn(FuncName) && !BuiltInFunctionSummaries.isSummarized(FuncName)) {
            SILFunctionRef FuncRef = new SILFunctionRef(result.Name, result.Type, C, FuncName);
            C.valueTable.addValue(FuncRef);
            if (!Inliner.shouldInlineFunction(FuncName, C)) {
               C.parent.addScopedEntity(null, findEntity(FuncName, C.allEntities));
            }
        } else if (BuiltInFunctionSummaries.isSummarized(FuncName)) {
            SILFunctionRef.SILSummarizedFunctionRef FuncRef =
                    new SILFunctionRef.SILSummarizedFunctionRef(result.Name, result.Type, C, FuncName);
            C.valueTable.addValue(FuncRef);
        } else {
            SILConstant Constant = new SILConstant(result.Name, result.Type, C, FuncName);
            C.valueTable.addValue(Constant);
        }
        return null;
}

    @Override
    // FREQUENCY: COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: MED
    protected CAstNode visitDynamicFunctionRef(CAstNode N, SILInstructionContext C) {
        // Treat like regular function ref since we can still get the function name.
        // TODO: INVESTIGATE: This function can apparently by replaced at runtime,
        //  but it is unclear if this is problematic.
        return visitFunctionRef(N, C);
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: MED
    protected CAstNode visitPrevDynamicFunctionRef(CAstNode N, SILInstructionContext C) {
        // Treat like regular function ref since we can still get the function name.
        // See visitDynamicFunctionRef about possible problems.
        return visitFunctionRef(N, C);
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitGlobalAddr(CAstNode N, SILInstructionContext C) {
        // Creates a references to the address of a global var. The result
        // is a pointer to the global var.
        RawValue result = getSingleResult(N);
        String GlobalName = getStringValue(N, 2);
        SILValue GlobalValue = C.valueTable.getValue(GlobalName);
        C.valueTable.addValue(GlobalValue.makePointer(result.Name, result.Type));
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitGlobalValue(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitIntegerLiteral(CAstNode N, SILInstructionContext C) {
        // Creates an integer literal value.
        RawValue result = getSingleResult(N);
        int Integer = getIntValue(N, 2);
        SILConstant IntegerValue = new SILConstant(result.Name, result.Type, C, Integer);
        C.valueTable.addValue(IntegerValue);
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitFloatLiteral(CAstNode N, SILInstructionContext C) {
        // Creates a float literal value.
        RawValue result = getSingleResult(N);
        float Float = ((BigDecimal)N.getChild(2).getValue()).floatValue();
        SILConstant FloatValue = new SILConstant(result.Name, result.Type, C, Float);
        C.valueTable.addValue(FloatValue);
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitStringLiteral(CAstNode N, SILInstructionContext C) {
        // Creates a string literal value.
        RawValue result = getSingleResult(N);
        String StringValue = getStringValue(N, 2);
        SILConstant Value = new SILConstant(result.Name, result.Type, C, StringValue);
        C.valueTable.addValue(Value);
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitClassMethod(CAstNode N, SILInstructionContext C) {
        RawValue result = getSingleResult(N);
        String FuncName = getStringValue(N, 2);
        SILConstant Constant = new SILConstant(result.Name, result.Type, C, FuncName);
        C.valueTable.addValue(Constant);
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitObjCMethod(CAstNode N, SILInstructionContext C) {
        // TODO: Need to figure out how these work and if they are effectively
        //  black box calls.
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitSuperMethod(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitObjCSuperMethod(CAstNode N, SILInstructionContext C) {
        // TODO: Need to figure out how these work and if they are effectively
        //  black box calls.
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitWitnessMethod(CAstNode N, SILInstructionContext C) {
        // Treat like regular function ref since we can still get the function name.
        return visitFunctionRef(N, C);
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitApply(CAstNode N, SILInstructionContext C) {
        // Apply a function. Behavior depends on the function expr and type of call
        // If the C++ side has created a binary/unary expression then it is an
        // operation, otherwise we treat it as a call. See visitFunctionRef.
        RawValue result = getSingleResult(N);
        String FuncRefName = getStringValue(N, 2);
        CAstNode Source;
        CAstNode FuncNode = N.getChild(3);
        switch (FuncNode.getKind()) {
            case CAstNode.UNARY_EXPR: {
                CAstNode Oper = C.valueTable.getValue(getStringValue(FuncNode, 1)).getVarNode();
                Source = Ast.makeNode(CAstNode.UNARY_EXPR, FuncNode.getChild(0), Oper);
                C.valueTable.addValue(new SILValue(result.Name, result.Type, C));
                break;
            }
            case CAstNode.BINARY_EXPR: {
                CAstNode Oper1 = C.valueTable.getValue(getStringValue(FuncNode, 1)).getVarNode();
                CAstNode Oper2 = C.valueTable.getValue(getStringValue(FuncNode, 2)).getVarNode();
                Source = Ast.makeNode(CAstNode.BINARY_EXPR, FuncNode.getChild(0), Oper1, Oper2);
                C.valueTable.addValue(new SILValue(result.Name, result.Type, C));
                break;
            }
            default: {
                String CalleeName = (String) FuncNode.getChild(0).getValue();
                SILValue FuncRef = C.valueTable.getValue(FuncRefName);
                if (FuncRef instanceof SILConstant) {
                    Source = ((SILConstant) FuncRef).getCAst();
                    C.valueTable.addValue(new SILValue(result.Name, result.Type, C));
                } else if (FuncRef instanceof SILFunctionRef) {
                    ArrayList<CAstNode> Params = new ArrayList<>();
                    ArrayList<SILValue> ParamVals = new ArrayList<>();
                    Params.add(((SILFunctionRef) FuncRef).getFunctionRef());
                    Params.add(Ast.makeConstant("do"));
                    for (CAstNode RawParam : FuncNode.getChildren().subList(1, FuncNode.getChildren().size())) {
                        String ParamName = (String)RawParam.getValue();
                        Params.add(C.valueTable.getValue(ParamName).getVarNode());
                        ParamVals.add(C.valueTable.getValue(ParamName));
                    }
                    if (Inliner.shouldInlineFunction(((SILFunctionRef) FuncRef).getFunctionName(), C)) {
                        SILValue ReturnValue = Inliner.doFunctionInline(((SILFunctionRef) FuncRef)
                                .getFunctionName(), C, ParamVals, this);
                        C.valueTable.copyValue(result.Name, ReturnValue.getName());
                        return Ast.makeNode(CAstNode.EMPTY);
                    }
                    Source = Ast.makeNode(CAstNode.CALL, Params);
                    C.parent.setGotoTarget(Source, Source);
                    C.valueTable.addValue(new SILValue(result.Name, result.Type, C));
                } else if (FuncRef instanceof SILFunctionRef.SILSummarizedFunctionRef) {
                    ArrayList<CAstNode> Params = new ArrayList<>(FuncNode.getChildren()
                            .subList(1, FuncNode.getChildren().size()));
                    C.valueTable.addValue(new SILValue(result.Name, result.Type, C));
                    Source = BuiltInFunctionSummaries.findSummary(
                            ((SILFunctionRef.SILSummarizedFunctionRef)FuncRef).getFunctionName(),
                            result.Name, result.Type, C, Params);
                    if (Source == null || Source.getKind() == CAstNode.EMPTY) {
                        return Ast.makeNode(CAstNode.EMPTY);
                    } else if (Source.getKind() == CAstNode.VAR) {
                        C.valueTable.addValue(new SILValue(result.Name, result.Type, C));
                        return Ast.makeNode(CAstNode.EMPTY);
                    }
                } else {
                    Source = Ast.makeConstant("UNKNOWN");
                    C.valueTable.addValue(new SILValue(result.Name, result.Type, C));
                }
                break;
            }
        }
        return Ast.makeNode(CAstNode.ASSIGN, C.valueTable.getValue(result.Name).getVarNode(), Source);
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitBeginApply(CAstNode N, SILInstructionContext C) {
        // TODO:
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitAbortApply(CAstNode N, SILInstructionContext C) {
        // TODO:
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitEndApply(CAstNode N, SILInstructionContext C) {
        // TODO:
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitPartialApply(CAstNode N, SILInstructionContext C) {
        // TODO: Very weird instruction.
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitBuiltin(CAstNode N, SILInstructionContext C) {
        // TODO:
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitMetatype(CAstNode N, SILInstructionContext C) {
        // Creates a metatype value. A constant is sufficient to handle this.
        RawValue result = getSingleResult(N);
        SILConstant Value = new SILConstant(result.Name, result.Type, C, result.Type);
        C.valueTable.addValue(Value);
        return null;
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitValueMetatype(CAstNode N, SILInstructionContext C) {
        // Here, we can ignore the operand, even though the result is based on it.
        // The result type != operand type so we just create a new value.
        return visitMetatype(N, C);
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitExistentialMetatype(CAstNode N, SILInstructionContext C) {
        // Similar to value_metatype.
        return visitValueMetatype(N, C);
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitObjCProtocol(CAstNode N, SILInstructionContext C) {
        // TODO: No SIL.rst info.
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitRetainValue(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitRetainValueAddr(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitUnmanagedRetainValue(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitCopyValue(CAstNode N, SILInstructionContext C) {
        // Regular copy operation. Implicit for now.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitReleaseValue(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitReleaseValueAddr(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
}

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitUnmanagedReleaseValue(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE:
    protected CAstNode visitDestroyValue(CAstNode N, SILInstructionContext C) {
        C.valueTable.removeValue(getSingleOperand(N).Name);
        return null;
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitAutoreleaseValue(CAstNode N, SILInstructionContext C) {
        // No SIL.rst documentation, but it seems it just releases (deletes) the
        // value so we remove it from the table.
        C.valueTable.removeValue(getSingleOperand(N).Name);
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitTuple(CAstNode N, SILInstructionContext C) {
        // Creates a tuple. We create a SILTuple to keep track of it.
        RawValue result = getSingleResult(N);
        ArrayList<CAstNode> NodeFields = new ArrayList<>();
        NodeFields.add(Ast.makeNode(CAstNode.NEW, Ast.makeConstant(result.Type)));
        ArrayList<String> FieldTypes = new ArrayList<>();
        int index = 0;
        for (CAstNode field : N.getChild(2).getChildren()) {
            String FieldValue = getStringValue(field, 0);
            String FieldType = getStringValue(field, 1);
            NodeFields.add(Ast.makeConstant(index));
            NodeFields.add(C.valueTable.getValue(FieldValue).getVarNode());
            FieldTypes.add(FieldType);
            ++index;
        }
        SILTuple ResultTuple = new SILTuple(result.Name, result.Type, C, FieldTypes);
        C.valueTable.addValue(ResultTuple);
        CAstNode ObjLiteral = Ast.makeNode(CAstNode.OBJECT_LITERAL, NodeFields);
        C.parent.setGotoTarget(ObjLiteral, ObjLiteral);
        return Ast.makeNode(CAstNode.ASSIGN, ResultTuple.getVarNode(), ObjLiteral);
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitTupleExtract(CAstNode N, SILInstructionContext C) {
        // Given a tuple value, extract an element from it based on given index.
        // Implicit for now.
        RawValue result = getSingleResult(N);
        RawValue operand = getSingleOperand(N);
        int Index = Integer.parseInt(getStringValue(N, 2));
        SILValue TupleValue = C.valueTable.getValue(operand.Name);
        // NOTE: Does this ever get called on a SILUnitArrayTuple? Unlikely.
        Assertions.productionAssertion(TupleValue instanceof SILTuple);
        SILValue ResultValue = ((SILTuple)TupleValue).createField(result.Name, Index);
        C.valueTable.addValue(ResultValue);
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitTupleElementAddr(CAstNode N, SILInstructionContext C) {
        // Same as tuple_extract except the operand is a pointer to the tuple.
        RawValue result = getSingleResult(N);
        RawValue operand = getSingleOperand(N);
        int Index = Integer.parseInt(getStringValue(N, 2));
        SILValue TuplePointer = C.valueTable.getValue(operand.Name);
        // NOTE: Does this ever get called on a SILUnitArrayTuple?
        Assertions.productionAssertion(TuplePointer instanceof SILPointer);
        SILValue TupleValue = ((SILPointer)TuplePointer).dereference();
        Assertions.productionAssertion(TupleValue instanceof SILTuple);
        SILValue ResultValue = ((SILTuple)TupleValue).createField(result.Name, Index);
        C.valueTable.addValue(ResultValue);
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitDestructureTuple(CAstNode N, SILInstructionContext C) {
        // Split the given tuple value into its constituents.
        RawValue result1 = getResult(N, 0);
        RawValue result2 = getResult(N, 1);
        RawValue operand = getSingleOperand(N);
        SILValue OperandValue = C.valueTable.getValue(operand.Name);
        if (OperandValue instanceof SILTuple) {
            SILField element1 = new SILField(result1.Name, result1.Type, C, OperandValue, "0");
            SILField element2 = new SILField(result2.Name, result2.Type, C, OperandValue, "1");
            C.valueTable.addValue(element1);
            C.valueTable.addValue(element2);
        } else if (OperandValue instanceof SILTuple.SILUnitArrayTuple) {
            SILValue ArrayValue = new SILValue(result1.Name, result1.Type, C);
            SILPointer PointerValue = new SILPointer(result2.Name, result2.Type, C, ArrayValue);
            C.valueTable.addValue(ArrayValue);
            C.valueTable.addValue(PointerValue);
        } else {
            Assertions.UNREACHABLE("Operation undefined for non-tuple types");
        }
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitStruct(CAstNode N, SILInstructionContext C) {
        // Creates a struct. We create a SILStruct to keep track of it.
        // Unlike a tuple, the struct has field names instead of indexes.
        RawValue result = getSingleResult(N);
        ArrayList<CAstNode> NodeFields = new ArrayList<>();
        NodeFields.add(Ast.makeNode(CAstNode.NEW, Ast.makeConstant(result.Type)));
        ArrayList<Pair<String, String>> Fields = new ArrayList<>();
        for (CAstNode field : N.getChild(2).getChildren()) {
            String FieldName = getStringValue(field, 0);
            String FieldValue = getStringValue(field, 1);
            NodeFields.add(Ast.makeConstant(FieldName));
            NodeFields.add(C.valueTable.getValue(FieldValue).getVarNode());
            Fields.add(Pair.make(FieldName, FieldValue));
        }
        SILStruct ResultStruct = new SILStruct(result.Name, result.Type, C, Fields);
        C.valueTable.addValue(ResultStruct);
        CAstNode ObjLiteral = Ast.makeNode(CAstNode.OBJECT_LITERAL, NodeFields);
        C.parent.setGotoTarget(ObjLiteral, ObjLiteral);
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitStructExtract(CAstNode N, SILInstructionContext C) {
        // Extracts an element from the given struct based on the given field name.
        RawValue result = getSingleResult(N);
        String StructName = getStringValue(N, 2);
        String FieldName = getStringValue(N, 3);
        SILValue StructValue = C.valueTable.getValue(StructName);
        if (StructValue instanceof SILStruct) {
            SILValue FieldValue = ((SILStruct)StructValue).createField(result.Name, result.Type, FieldName);
            C.valueTable.addValue(FieldValue);
            return null;
        } else {
            SILValue FieldValue = new SILValue(result.Name, result.Type, C);
            C.valueTable.addValue(FieldValue);
            return Ast.makeNode(CAstNode.ASSIGN,
                    FieldValue.getVarNode(),
                    C.valueTable.getValue(StructName).createObjectRef(FieldName));
        }
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitStructElementAddr(CAstNode N, SILInstructionContext C) {
        // Same as struct_extract except the operand is a pointer to the struct.
        RawValue result = getSingleResult(N);
        RawValue operand = getSingleOperand(N);
        String StructName = getStringValue(N, 2);
        String FieldName = getStringValue(N, 3);
        SILValue OperandValue = C.valueTable.getValue(operand.Name);
        Assertions.productionAssertion(OperandValue instanceof SILPointer);
        SILValue UnderlyingValue = ((SILPointer)OperandValue).dereference();
        SILField NewField = new SILField(null, null, C, UnderlyingValue, FieldName);
        SILPointer ResultPointer = new SILPointer(result.Name, result.Type, C, NewField);
        C.valueTable.addValue(ResultPointer);
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitDestructureStruct(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitObject(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitRefElementAddr(CAstNode N, SILInstructionContext C) {
        // Given a class instance, return the address of the desired field.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        String FieldName = getStringValue(N, 2);
        SILValue OperandValue = C.valueTable.getValue(operand.Name);
        SILValue FieldValue = new SILField(null, null, C, OperandValue, FieldName);
        SILPointer ResultPointer = new SILPointer(result.Name, result.Type, C, FieldValue);
        C.valueTable.addValue(ResultPointer);
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitRefTailAddr(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitEnum(CAstNode N, SILInstructionContext C) {
        // Creates an enum. We don't care about the exact case because it will
        // be the result type. We don't care if the case has a data type because
        // if we add the operand (if it even exists) to the enum incorrectly, it
        // will never be used anyway.
        RawValue result = getSingleResult(N);
        String EnumName = getStringValue(N, 2);
        String CaseName = getStringValue(N, 3);
        SILValue OperandValue = null;
        try {
            RawValue operand = getSingleOperand(N);
            OperandValue = C.valueTable.getValue(operand.Name);
        } catch (Exception ignored) {}
        @SuppressWarnings("ConstantConditions")
        SILEnum EnumValue = new SILEnum(result.Name, result.Type, C, OperandValue);
        C.valueTable.addValue(EnumValue);
        return null;
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitUncheckedEnumData(CAstNode N, SILInstructionContext C) {
        // Unsafely extract data from enum. Here we chose to use a field ref, but it
        // could theoretically be a copy - it doesn't matter.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        SILValue OperandValue = C.valueTable.getValue(operand.Name);
        Assertions.productionAssertion(OperandValue instanceof SILEnum);
        SILField FieldValue = ((SILEnum)OperandValue).createField(result.Name, result.Type);
        C.valueTable.addValue(FieldValue);
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitInitEnumDataAddr(CAstNode N, SILInstructionContext C) {
        // Returns a pointer pointing to the enum's data.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        SILValue OperandValue = C.valueTable.getValue(operand.Name);
        Assertions.productionAssertion(OperandValue instanceof SILEnum);
        SILField FieldValue = ((SILEnum)OperandValue).createField(null, null);
        SILPointer ResultPointer = new SILPointer(result.Name, result.Type, C, FieldValue);
        C.valueTable.addValue(ResultPointer);
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitInjectEnumAddr(CAstNode N, SILInstructionContext C) {
        // Inits the enum value by overlaying a tag for the given case.
        // NOP
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitUncheckedTakeEnumDataAddr(CAstNode N, SILInstructionContext C) {
        // Given a pointer to an enum, take the address
        // of the payload for the given enum case.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        SILValue OperandValue = C.valueTable.getValue(operand.Name);
        Assertions.productionAssertion(OperandValue instanceof SILPointer);
        SILValue EnumValue = ((SILPointer)OperandValue).dereference();
        Assertions.productionAssertion(EnumValue instanceof SILEnum);
        SILField FieldValue = ((SILEnum)EnumValue).createField(null, null);
        SILPointer ResultPointer = new SILPointer(result.Name, result.Type, C, FieldValue);
        C.valueTable.addValue(ResultPointer);
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitSelectEnum(CAstNode N, SILInstructionContext C) {
        // TODO: Switch problem
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitSelectEnumAddr(CAstNode N, SILInstructionContext C) {
        // TODO: Switch problem
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitInitExistentialAddr(CAstNode N, SILInstructionContext C) {
        // The type changes so we create a new pointer to the same underlying
        // value as the operand pointer.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        Assertions.productionAssertion(C.valueTable.getValue(operand.Name) instanceof SILPointer);
        SILPointer OperandPointer = (SILPointer)C.valueTable.getValue(operand.Name);
        SILValue ValueReferenced = OperandPointer.dereference();
        SILPointer ResultPointer = new SILPointer(result.Name, result.Type, C, ValueReferenced);
        C.valueTable.addValue(ResultPointer);
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitInitExistentialValue(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitDeinitExistentialAddr(CAstNode N, SILInstructionContext C) {
        // De-inits the underlying value of the pointer operand. We can just remove
        // the underlying value from the table.
        RawValue operand = getSingleOperand(N);
        Assertions.productionAssertion(C.valueTable.getValue(operand.Name) instanceof SILPointer);
        SILPointer OperandPointer = (SILPointer)C.valueTable.getValue(operand.Name);
        C.valueTable.removeValue(OperandPointer.dereference().getName());
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitDeinitExistentialValue(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: MED
    protected CAstNode visitOpenExistentialAddr(CAstNode N, SILInstructionContext C) {
        // Basically creates a new pointer to the same concrete value inside of the
        // pointer operand. This is just a point copy, but the result has a different
        // type.
        RawValue result = getSingleResult(N);
        RawValue operand = getSingleOperand(N);
        // NOTE: This assertion may be wrong since its possible the operand is of
        // "protocol composition type P". For now we will leave it.
        Assertions.productionAssertion(C.valueTable.getValue(operand.Name) instanceof SILPointer);
        SILPointer OperandPointer = (SILPointer)C.valueTable.getValue(operand.Name);
        SILPointer NewPointer = new SILPointer(result.Name, result.Type, C, OperandPointer.dereference());
        C.valueTable.addValue(NewPointer);
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitOpenExistentialValue(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: MED
    protected CAstNode visitInitExistentialRef(CAstNode N, SILInstructionContext C) {
        // Creates a class reference to the class instance operand.
        RawValue result = getSingleResult(N);
        RawValue operand = getSingleOperand(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: MED
    protected CAstNode visitOpenExistentialRef(CAstNode N, SILInstructionContext C) {
        // Creates a reference to the operand ($P to $@opened P). The SIL.rst
        // refers to the result as a "pointer", but we will ignore that for now.
        RawValue result = getSingleResult(N);
        RawValue operand = getSingleOperand(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: MED
    protected CAstNode visitInitExistentialMetatype(CAstNode N, SILInstructionContext C) {
        // Creates metatype existential container of a type based on the operand
        // which originates from a metatype. For now, we just do a copy.
        RawValue result = getSingleResult(N);
        RawValue operand = getSingleOperand(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: MED
    protected CAstNode visitOpenExistentialMetatype(CAstNode N, SILInstructionContext C) {
        // More metatype stuff we don't care about.
        RawValue result = getSingleResult(N);
        RawValue operand = getSingleOperand(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitAllocExistentialBox(CAstNode N, SILInstructionContext C) {
        // Allocated a boxed existential container. We treat boxes as pointers.
       return visitAllocBox(N, C);
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitProjectExistentialBox(CAstNode N, SILInstructionContext C) {
        // Returns a pointer to the value inside the boxed container.
        return visitProjectBox(N, C);
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: MED
    protected CAstNode visitOpenExistentialBox(CAstNode N, SILInstructionContext C) {
        // Projects the value inside the box. Assume we can just copy the pointer.
        RawValue result = getSingleResult(N);
        RawValue operand = getSingleOperand(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitOpenExistentialBoxValue(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitDeallocExistentialBox(CAstNode N, SILInstructionContext C) {
        // Destroys a boxed existential container. This means we can just remove it
        // from the table.
        RawValue operand = getSingleOperand(N);
        C.valueTable.removeValue(operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitProjectBlockStorage(CAstNode N, SILInstructionContext C) {
        // No SIL.rst documentation. Appears that the result is a pointer to the
        // operand.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        SILValue OperandValue = C.valueTable.getValue(operand.Name);
        SILPointer NewPointer = new SILPointer(result.Name, result.Type, C, OperandValue);
        C.valueTable.addValue(NewPointer);
        return null;
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: LOW
    protected CAstNode visitInitBlockStorageHeader(CAstNode N, SILInstructionContext C) {
        // Appears to initialize a memory location (first operand).
        // From the swift code the second operand is the "invoke function to form the
        // block around." For now we ignore the invoke function operand because we
        // are unsure if it is actually called. The return value is a (non-pointer)
        // block type, so perhaps just the underlying value of the operand?
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        String functionValueName = getStringValue(N, 2);
        Assertions.productionAssertion(C.valueTable.getValue(operand.Name) instanceof SILPointer);
        SILPointer OperandPointer = (SILPointer)C.valueTable.getValue(operand.Name);
        Assertions.productionAssertion(C.valueTable.getValue(functionValueName) instanceof SILFunctionRef);
        SILFunctionRef InvokeFunction = (SILFunctionRef)C.valueTable.getValue(functionValueName);
        C.valueTable.copyValue(result.Name, OperandPointer.dereference().getName());
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitUpcast(CAstNode N, SILInstructionContext C) {
        // Regular class upcast. We just do a copy.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitAddressToPointer(CAstNode N, SILInstructionContext C) {
        // We treat $Builtin.RawPointer and regular pointers as the same, so this
        // is just a copy.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitPointerToAddress(CAstNode N, SILInstructionContext C) {
        // We treat $Builtin.RawPointer and regular pointers as the same, so this
        // is just a copy.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitUncheckedRefCast(CAstNode N, SILInstructionContext C) {
        // A regular cast just for heap object reference types.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitUncheckedRefCastAddr(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitUncheckedAddrCast(CAstNode N, SILInstructionContext C) {
        // A regular cast just for addresses.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitUncheckedTrivialBitCast(CAstNode N, SILInstructionContext C) {
        // Bitcast of an object to different type (ignore the specifics).
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitUncheckedBitwiseCast(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitUncheckedOwnershipConversion(CAstNode N, SILInstructionContext C) {
        // No SIL.rst documentation. In practice, looks like some low level
        // operation but the result and operand have the same type.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitRefToRawPointer(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitRawPointerToRef(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitRefToUnowned(CAstNode N, SILInstructionContext C) {
        // Treat as regular cast.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitUnownedToRef(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitRefToUnmanaged(CAstNode N, SILInstructionContext C) {
        // No SIL.rst documentation. Treat as regular cast.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitUnmanagedToRef(CAstNode N, SILInstructionContext C) {
        // No SIL.rst documentation. Treat as regular cast.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitConvertFunction(CAstNode N, SILInstructionContext C) {
        // Changes function type (but not name). Treat as regular cast.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitConvertEscapeToNoEscape(CAstNode N, SILInstructionContext C) {
        // Changes function escape property. Treat as regular cast.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitThinFunctionToPointer(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitPointerToThinFunction(CAstNode N, SILInstructionContext C) {
        // Cast problem
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitClassifyBridgeObject(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitValueToBridgeObject(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitRefToBridgeObject(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitBridgeObjectToRef(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitBridgeObjectToWord(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitThinToThickFunction(CAstNode N, SILInstructionContext C) {
        // Treat as regular cast.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitThickToObjCMetatype(CAstNode N, SILInstructionContext C) {
        // Treat as regular cast.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitObjCToThickMetatype(CAstNode N, SILInstructionContext C) {
        // Treat as regular cast.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitObjCMetatypeToObject(CAstNode N, SILInstructionContext C) {
        // No SIL.rst documentation. Treat as regular cast.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitObjCExistentialMetatypeToObject(CAstNode N, SILInstructionContext C) {
        // No SIL.rst documentation. Treat as regular cast.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitUnconditionalCheckedCast(CAstNode N, SILInstructionContext C) {
        // Treat as regular cast.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitUnconditionalCheckedCastAddr(CAstNode N, SILInstructionContext C) {
        // Treat as regular cast.
        RawValue operand = getSingleOperand(N);
        RawValue result = getSingleResult(N);
        C.valueTable.copyValue(result.Name, operand.Name);
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitUnconditionalCheckedCastValue(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitCondFail(CAstNode N, SILInstructionContext C) {
        // TODO: Causes runtime failure with operand (int) as exit code,
        //  so exception to exit?
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitUnreachable(CAstNode N, SILInstructionContext C) {
        // TODO:
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitReturn(CAstNode N, SILInstructionContext C) {
        // Returns the operand. For us, in the case that the function is being inlined,
        // we need to set the context.
        RawValue operand = getSingleOperand(N);
        if (C.inliningParent) {
            C.returnValue = C.valueTable.getValue(operand.Name);
            return Ast.makeNode(CAstNode.LABEL_STMT, Ast.makeConstant("Returning " + C.returnValue.getName()));
        } else {
            return Ast.makeNode(CAstNode.RETURN, C.valueTable.getValue(operand.Name).getVarNode());
        }
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitThrow(CAstNode N, SILInstructionContext C) {
        // Need to figure out how exception handling will work in general.
        // We can use JS exception to exit, but that won't be precise because
        // throwing control flow is usually handled by the caller explicitly.
        // e.g. try_apply TODO
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: MED
    protected CAstNode visitYield(CAstNode N, SILInstructionContext C) {
        // Yield the operands to the caller. Unclear if YIELD_STMT works
        // the way we want.
        String ResumeLabel = getStringValue(N, 0);
        String UnwindLabel = getStringValue(N, 1);
        ArrayList<CAstNode> YieldValues = new ArrayList<>();
        for (CAstNode value : N.getChild(2).getChildren()) {
            YieldValues.add(C.valueTable.getValue((String)value.getValue()).getVarNode());
        }
        YieldValues.add(Ast.makeConstant(ResumeLabel));
        YieldValues.add(Ast.makeConstant(UnwindLabel));
        return Ast.makeNode(CAstNode.YIELD_STMT, YieldValues);
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitUnwind(CAstNode N, SILInstructionContext C) {
        // TODO
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return Ast.makeNode(CAstNode.UNWIND);
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitBr(CAstNode N, SILInstructionContext C) {
        // Branch to another block. We also decide if we should inline
        // the destination block, since blocks are basically functions.
        String DestBranch = getStringValue(N, 0);
        int DestBlockNo = Integer.parseInt(DestBranch);
        if (Inliner.shouldInlineBlock(DestBlockNo, C)) {
            ArrayList<SILValue> args = new ArrayList<>();
            for (CAstNode arg : N.getChild(1).getChildren()) {
                String ArgName = getStringValue(arg, 0);
                SILValue ArgValue = C.valueTable.getValue(ArgName);
                args.add(ArgValue);
            }
            Inliner.doBlockInline(N, DestBlockNo, C, args, this);
            return null;
        } else {
            for (CAstNode arg : N.getChild(1).getChildren()) {
                String OperandName = getStringValue(arg, 0);
                String DestArgName = getStringValue(arg, 1);
                String DestArgType = getStringValue(arg, 2);
                SILValue OperandValue = C.valueTable.getValue(OperandName);
                CAstNode ResultAssign = OperandValue.copy(DestArgName, DestArgType);
                if (ResultAssign != null) {
                    C.instructions.add(ResultAssign);
                }
            }
            CAstNode GotoNode = Ast.makeNode(CAstNode.GOTO, Ast.makeConstant(DestBranch));
            tryGOTO(GotoNode, DestBranch, C);
            return GotoNode;
        }
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: TRANSLATED
    // CONFIDENCE: HIGH
    protected CAstNode visitCondBr(CAstNode N, SILInstructionContext C) {
        // Branch based on condition. Has a true block and a false block.
        String CondOperandName = getStringValue(N, 0);
        String TrueDestName = getStringValue(N, 1);
        String FalseDestName = getStringValue(N, 2);
        for (CAstNode arg : N.getChild(1).getChildren()) {
            String OperandName = getStringValue(arg, 0);
            String DestArgName = getStringValue(arg, 1);
            String DestArgType = getStringValue(arg, 2);
            SILValue OperandValue = C.valueTable.getValue(OperandName);
            CAstNode ResultAssign = OperandValue.copy(DestArgName, DestArgType);
            if (ResultAssign != null) {
                C.instructions.add(ResultAssign);
            }
        }
        CAstNode TrueGotoNode = Ast.makeNode(CAstNode.GOTO, Ast.makeConstant(TrueDestName));
        tryGOTO(TrueGotoNode, TrueDestName, C);
        for (CAstNode arg : N.getChild(2).getChildren()) {
            String OperandName = getStringValue(arg, 0);
            String DestArgName = getStringValue(arg, 1);
            String DestArgType = getStringValue(arg, 2);
            SILValue OperandValue = C.valueTable.getValue(OperandName);
            CAstNode ResultAssign = OperandValue.copy(DestArgName, DestArgType);
            if (ResultAssign != null) {
                C.instructions.add(ResultAssign);
            }
        }
        CAstNode FalseGotoNode = Ast.makeNode(CAstNode.GOTO, Ast.makeConstant(FalseDestName));
        tryGOTO(FalseGotoNode, FalseDestName, C);
        return Ast.makeNode(CAstNode.IF_STMT,
                Ast.makeNode(CAstNode.BINARY_EXPR, CAstOperator.OP_EQ,
                    C.valueTable.getValue(CondOperandName).getVarNode(),
                    Ast.makeConstant("1")),
                TrueGotoNode, FalseGotoNode);
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitSwitchValue(CAstNode N, SILInstructionContext C) {
        // TODO: Switch problem
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitSelectValue(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: VERY COMMON
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitSwitchEnum(CAstNode N, SILInstructionContext C) {
        // Switch problem TODO
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        /*
        String EnumName = (String)N.getChild(0).getValue();
        SILValue EnumValue = C.valueTable.getValue(EnumName);
        ArrayList<CAstNode> Fields = new ArrayList<>();
        CAstNode DefaultNode = CAstControlFlowRecorder.EXCEPTION_TO_EXIT;
        ArrayList<Pair<CAstNode, CAstNode>> labels = new ArrayList<>();
        for (CAstNode Case : N.getChild(1).getChildren()) {
            ArrayList<CAstNode> StmtNodes = new ArrayList<>();
            String CaseName = (String)Case.getChild(0).getValue();
            String DestBB = (String)Case.getChild(1).getValue();
            if (N.getChildren().size() > 2) {
                String ArgName = (String)N.getChild(2).getValue();
                String ArgType = (String)N.getChild(3).getValue();
                CAstNode Assign = EnumValue.copy(ArgName, ArgType);
                if (Assign != null) {
                    C.instructions.add(Assign);
                }
            }
            CAstNode LabelStmt = Ast.makeNode(CAstNode.LABEL_STMT, Ast.makeConstant(CaseName));
            CAstNode GotoNode = Ast.makeNode(CAstNode.GOTO, Ast.makeConstant(DestBB));
            tryGOTO(GotoNode, DestBB, C);
            StmtNodes.add(LabelStmt);
            StmtNodes.add(GotoNode);
            CAstNode BlockStmt = Ast.makeNode(CAstNode.BLOCK_STMT, StmtNodes);
            labels.add(Pair.make(BlockStmt, LabelStmt));
            Fields.add(BlockStmt);
        }
        if (N.getChildren().size() > 2) {
            ArrayList<CAstNode> StmtNodes = new ArrayList<>();
            CAstNode DefaultInfo = N.getChild(2);
            String DestBB = (String)DefaultInfo.getChild(0).getValue();
            if (DefaultInfo.getChildren().size() > 1) {
                String ArgName = (String)DefaultInfo.getChild(1).getValue();
                String ArgType = (String)DefaultInfo.getChild(2).getValue();
                CAstNode Assign = EnumValue.copy(ArgName, ArgType);
                if (Assign != null) {
                    C.instructions.add(Assign);
                }
            }
            CAstNode LabelStmt = Ast.makeNode(CAstNode.LABEL_STMT, Ast.makeConstant("default"));
            CAstNode GotoNode = Ast.makeNode(CAstNode.GOTO, Ast.makeConstant(DestBB));
            tryGOTO(GotoNode, DestBB, C);
            StmtNodes.add(LabelStmt);
            StmtNodes.add(GotoNode);
            CAstNode BlockStmt = Ast.makeNode(CAstNode.BLOCK_STMT, StmtNodes);
            DefaultNode = BlockStmt;
            Fields.add(BlockStmt);
        }
        CAstNode Switch = Ast.makeNode(CAstNode.SWITCH,
                EnumValue.getVarNode(),
                Ast.makeNode(CAstNode.BLOCK_STMT, Fields));
        //C.parent.setGotoTarget(Switch, Switch);
        C.parent.setLabelledGotoTarget(Switch, DefaultNode, CAstControlFlowRecorder.SWITCH_DEFAULT);
        for (Pair<CAstNode, CAstNode> l : labels) {
            C.parent.setLabelledGotoTarget(Switch, l.fst, l.snd.getChild(0));
        }
        return Switch;
         */
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    protected CAstNode visitSwitchEnumAddr(CAstNode N, SILInstructionContext C) {
        // Switch problem
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: RARE
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitDynamicMethodBr(CAstNode N, SILInstructionContext C) {
        // TODO
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitCheckedCastBr(CAstNode N, SILInstructionContext C) {
        // TODO
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: UNSEEN
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitCheckedCastValueBr(CAstNode N, SILInstructionContext C) {
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: UNHANDLED
    // CONFIDENCE:
    protected CAstNode visitCheckedCastAddrBr(CAstNode N, SILInstructionContext C) {
        // TODO
        Assertions.UNREACHABLE("UNHANDLED INSTRUCTION");
        return null;
    }

    @Override
    // FREQUENCY: COMMON
    // STATUS: INCOMPLETE
    // CONFIDENCE: LOW
    protected CAstNode visitTryApply(CAstNode N, SILInstructionContext C) {
        // There are two options to handling the control flow of a thrown error.
        // 1. Return a value that is then checked in a conditional branch.
        // 2. Use whatever JS has for throw semantics. This might require passing the
        //    throw destination to the call site.
        // TODO
        String FuncRefName = (String)N.getChild(0).getValue();
        CAstNode Source;
        CAstNode FuncNode = N.getChild(1);
        switch (FuncNode.getKind()) {
            case CAstNode.UNARY_EXPR: {
                CAstNode Oper = C.valueTable.getValue((String)FuncNode.getChild(1).getValue()).getVarNode();
                Source = Ast.makeNode(CAstNode.UNARY_EXPR, FuncNode.getChild(0), Oper);
                break;
            }
            case CAstNode.BINARY_EXPR: {
                CAstNode Oper1 = C.valueTable.getValue((String)FuncNode.getChild(1).getValue()).getVarNode();
                CAstNode Oper2 = C.valueTable.getValue((String)FuncNode.getChild(2).getValue()).getVarNode();
                Source = Ast.makeNode(CAstNode.BINARY_EXPR, FuncNode.getChild(0), Oper1, Oper2);
                break;
            }
            default: {
                String CalleeName = (String) FuncNode.getChild(0).getValue();
                SILValue FuncRef = C.valueTable.getValue(FuncRefName);
                if (FuncRef instanceof SILConstant) {
                    Source = ((SILConstant) FuncRef).getCAst();
                } else if (FuncRef instanceof SILFunctionRef) {
                    ArrayList<CAstNode> Params = new ArrayList<>();
                    Params.add(((SILFunctionRef) FuncRef).getFunctionRef());
                    Params.add(Ast.makeConstant("do"));
                    for (CAstNode RawParam : FuncNode.getChildren().subList(1, FuncNode.getChildren().size())) {
                        Params.add(C.valueTable.getValue((String)RawParam.getValue()).getVarNode());
                    }
                    Source = Ast.makeNode(CAstNode.CALL, Params);
                    C.parent.setGotoTarget(Source, Source);
                } else if (FuncRef instanceof SILFunctionRef.SILSummarizedFunctionRef) {
                    ArrayList<CAstNode> Params = new ArrayList<>(FuncNode.getChildren().subList(1, FuncNode.getChildren().size()));
                    Source = BuiltInFunctionSummaries.findSummary(
                            ((SILFunctionRef.SILSummarizedFunctionRef)FuncRef).getFunctionName(),
                            null, null, C, Params);
                    if (Source == null || Source.getKind() == CAstNode.EMPTY) {
                        return Ast.makeNode(CAstNode.EMPTY);
                    } else if (Source.getKind() == CAstNode.VAR) {
                        return Ast.makeNode(CAstNode.EMPTY);
                    }
                } else {
                    Source = Ast.makeConstant("UNKNOWN");
                }
                break;
            }
        }
        return Source;
    }
}